package club.malvaceae.malloy.enchantments

import io.papermc.paper.enchantments.EnchantmentRarity
import net.kyori.adventure.text.Component
import org.bukkit.NamespacedKey
import org.bukkit.enchantments.Enchantment
import org.bukkit.enchantments.EnchantmentTarget
import org.bukkit.entity.EntityCategory
import org.bukkit.inventory.EquipmentSlot
import org.bukkit.inventory.ItemStack

class EnchantmentWrapper(val k: NamespacedKey, val n: String, val ml: Int) : Enchantment(k) {
    /**
     * Gets the translation key.
     *
     * @return the translation key
     * @since 4.8.0
     */
    override fun translationKey(): String {
        return translationKey()
    }

    /**
     * Gets the unique name of this enchantment
     *
     * @return Unique name
     */
    override fun getName(): String {
        return n
    }

    /**
     * Gets the maximum level that this Enchantment may become.
     *
     * @return Maximum level of the Enchantment
     */
    override fun getMaxLevel(): Int {
        return ml
    }

    /**
     * Gets the level that this Enchantment should start at
     *
     * @return Starting level of the Enchantment
     */
    override fun getStartLevel(): Int {
        return startLevel
    }

    /**
     * Gets the type of [ItemStack] that may fit this Enchantment.
     *
     * @return Target type of the Enchantment
     */
    override fun getItemTarget(): EnchantmentTarget {
        return itemTarget
    }

    /**
     * Checks if this enchantment is a treasure enchantment.
     * <br></br>
     * Treasure enchantments can only be received via looting, trading, or
     * fishing.
     *
     * @return true if the enchantment is a treasure enchantment
     */
    override fun isTreasure(): Boolean {
        return isTreasure
    }

    /**
     * Checks if this enchantment is a cursed enchantment
     * <br></br>
     * Cursed enchantments are found the same way treasure enchantments are
     *
     * @return true if the enchantment is cursed
     */
    override fun isCursed(): Boolean {
        return isCursed
    }

    /**
     * Check if this enchantment conflicts with another enchantment.
     *
     * @param other The enchantment to check against
     * @return True if there is a conflict.
     */
    override fun conflictsWith(other: Enchantment): Boolean {
        return conflictsWith(other)
    }

    /**
     * Checks if this Enchantment may be applied to the given [ ].
     *
     *
     * This does not check if it conflicts with any enchantments already
     * applied to the item.
     *
     * @param item Item to test
     * @return True if the enchantment may be applied, otherwise False
     */
    override fun canEnchantItem(item: ItemStack): Boolean {
        return canEnchantItem(item)
    }

    /**
     * Get the name of the enchantment with its applied level.
     *
     *
     * If the given `level` is either less than the [.getStartLevel] or greater than the [.getMaxLevel],
     * the level may not be shown in the numeral format one may otherwise expect.
     *
     *
     * @param level the level of the enchantment to show
     * @return the name of the enchantment with `level` applied
     */
    override fun displayName(level: Int): Component {
        return displayName(level)
    }

    /**
     * Checks if this enchantment can be found in villager trades.
     *
     * @return true if the enchantment can be found in trades
     */
    override fun isTradeable(): Boolean {
        return isTradeable
    }

    /**
     * Checks if this enchantment can be found in an enchanting table
     * or use to enchant items generated by loot tables.
     *
     * @return true if the enchantment can be found in a table or by loot tables
     */
    override fun isDiscoverable(): Boolean {
        return isDiscoverable
    }

    /**
     * Gets the minimum modified cost of this enchantment at a specific level.
     *
     *
     * Note this is not the number of experience levels needed, and does not directly translate to the levels shown in an enchanting table.
     * This value is used in combination with factors such as tool enchantability to determine a final cost.
     * See [https://minecraft.wiki/w/Enchanting/Levels](https://minecraft.wiki/w/Enchanting/Levels) for more information.
     *
     * @param level The level of the enchantment
     * @return The modified cost of this enchantment
     */
    override fun getMinModifiedCost(level: Int): Int {
        return getMinModifiedCost(level)
    }

    /**
     * Gets the maximum modified cost of this enchantment at a specific level.
     *
     *
     * Note this is not the number of experience levels needed, and does not directly translate to the levels shown in an enchanting table.
     * This value is used in combination with factors such as tool enchantability to determine a final cost.
     * See [https://minecraft.wiki/w/Enchanting/Levels](https://minecraft.wiki/w/Enchanting/Levels) for more information.
     *
     * @param level The level of the enchantment
     * @return The modified cost of this enchantment
     */
    override fun getMaxModifiedCost(level: Int): Int {
        return getMaxModifiedCost(level)
    }

    /**
     * Gets the rarity of this enchantment.
     *
     * @return the rarity
     */
    override fun getRarity(): EnchantmentRarity {
        return rarity
    }

    /**
     * Gets the damage increase as a result of the level and entity category specified
     *
     * @param level the level of enchantment
     * @param entityCategory the category of entity
     * @return the damage increase
     */
    override fun getDamageIncrease(level: Int, entityCategory: EntityCategory): Float {
        return getDamageIncrease(level, entityCategory)
    }

    /**
     * Gets the equipment slots where this enchantment is considered "active".
     *
     * @return the equipment slots
     */
    override fun getActiveSlots(): MutableSet<EquipmentSlot> {
        return activeSlots
    }
}